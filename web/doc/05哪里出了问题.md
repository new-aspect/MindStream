
```javascript
<script type="text/babel" data-type="module">
import React, {StrictMode} from 'react';
import {createRoot} from 'react-dom/client';

import {useState} from 'react'

function Square({value}){
    return <button className="square">{value}</button>
}

let App = function Board(){
    const[squares,setSquares] = useState(Array(9).fill('X'));

    setSquares(squares.map(t=>{
      if (t==='X') {
        return 'O'
      }
    })) 

    return(
        <>
            <div className="board-row">
              <Square value={squares[0]}/>
              <Square value={squares[1]}/>
              <Square value={squares[2]}/>
            </div>
            <div className="board-row">
              <Square value={squares[3]}/>
              <Square value={squares[4]}/>
              <Square value={squares[5]}/>
            </div>
            <div className="board-row">
              <Square value={squares[6]}/>
              <Square value={squares[7]}/>
              <Square value={squares[8]}/>
            </div>
        </>
    )
}

const root = createRoot(document.getElementById('root'))
root.render(
  <StrictMode>
    <App/>
  </StrictMode>
)


</script>
```

与React的渲染机制有关，

你在`App` 中直接更新状态`squares` 是不对的，React的`useState`钩子函数返回的是一个状态值和一个更新状态的函数。
你在`App`组件主题直接调用了`setSquares`来更新状态，并试图在每次更新时渲染状态，这会导致无限循环的状态更新，
因为每次状态都会导致组件重新渲染，而组件重新渲染会再次改变状态

```javascript

function Square({value,onClick}) {
    return <button className="square" onClick={onClick}>{value}</button>
}

let App = function Board(){
    const[squares,setSquares] = useState(Array(9).fill('X'));
    
    const handleClick = (index) => {
        const newSquares = squares.slice();
        newSquares[index] = squares[index] === 'X' ? 'O' : 'X';
        setSquares(newSquares);
    }

    return (
      <>
        <div className="board-row">
            <Square value={squares[0]} onClick={()=>handleClick(0)}/>
            <Square value={squares[1]} onClick={()=>handleClick(1)}/>

        </div>
      </>
    )
}
```
