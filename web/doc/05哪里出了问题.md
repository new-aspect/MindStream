
```javascript
<script type="text/babel" data-type="module">
import React, {StrictMode} from 'react';
import {createRoot} from 'react-dom/client';

import {useState} from 'react'

function Square({value}){
    return <button className="square">{value}</button>
}

let App = function Board(){
    const[squares,setSquares] = useState(Array(9).fill('X'));

    setSquares(squares.map(t=>{
      if (t==='X') {
        return 'O'
      }
    })) 

    return(
        <>
            <div className="board-row">
              <Square value={squares[0]}/>
              <Square value={squares[1]}/>
              <Square value={squares[2]}/>
            </div>
            <div className="board-row">
              <Square value={squares[3]}/>
              <Square value={squares[4]}/>
              <Square value={squares[5]}/>
            </div>
            <div className="board-row">
              <Square value={squares[6]}/>
              <Square value={squares[7]}/>
              <Square value={squares[8]}/>
            </div>
        </>
    )
}

const root = createRoot(document.getElementById('root'))
root.render(
  <StrictMode>
    <App/>
  </StrictMode>
)


</script>
```

与React的渲染机制有关，

你在`App` 中直接更新状态`squares` 是不对的，React的`useState`钩子函数返回的是一个状态值和一个更新状态的函数。
你在`App`组件主题直接调用了`setSquares`来更新状态，并试图在每次更新时渲染状态，这会导致无限循环的状态更新，
因为每次状态都会导致组件重新渲染，而组件重新渲染会再次改变状态

```javascript

function Square({value,onClick}) {
    return <button className="square" onClick={onClick}>{value}</button>
}

let App = function Board(){
    const[squares,setSquares] = useState(Array(9).fill('X'));
    
    const handleClick = (index) => {
        const newSquares = squares.slice();
        newSquares[index] = squares[index] === 'X' ? 'O' : 'X';
        setSquares(newSquares);
    }

    return (
      <>
        <div className="board-row">
            <Square value={squares[0]} onClick={()=>handleClick(0)}/>
            <Square value={squares[1]} onClick={()=>handleClick(1)}/>

        </div>
      </>
    )
}
```

# ()=>handleClick 是什么意思

`()=>handleClick(0)` 是一个箭头函数（Arrow Function）,用于创建一个匿名函数并传递参数

1. 箭头函数的基础
箭头函数是一种简写的函数表达式，语法为`()`或参数名`=>`函数体，他的主要作用是创建一个函数

```javascript
// 普通函数表达式
function example() {
  console.log('Hello');
}

// 等价的函数箭头
const example = () => {
  console.log('Hello')
}

```

2. 函数传递与参数绑定
在React中，通常需要将事件处理函数传递给组件中的某个元素（如`button`）。直接传递
带参数的函数会立即执行，而不是在事件发生时执行，因此我们需要用箭头函数延迟函数的执行

例如
```javascript
<button onClick={handleClick(0)}/>
```
上面的代码会立即执行`handleClick(0)`, 而不是在按钮被点击时执行。

为了防止这种情况，通常用函数箭头将函数调用延迟到事件发生时
```javascript
<button onClick={() => handleClick(0)}/> 
```

# 为什么React直接修改状态(useState的值)会导致问题
```javascript
<script type="text/babel" data-type="module">
import React, {StrictMode} from 'react';
import {createRoot} from 'react-dom/client';

import {useState} from 'react'

function Square({value,onclick}){
    return <button className="square" onClick={onclick}>{value}</button>
}

let App = function Board(){
    const[squares,setSquares] = useState(Array(9).fill('X'));

    const handleClick = (index) => {
      // const newSquares = squares.slice();
      // newSquares[index] = squares[index] === 'X' ? 'O' : 'X';
      // setSquares(newSquares);
      squares[index] = squares[index] === 'X' ? 'Y': 'X';
      setSquares(squares)
    }

    return(
        <>
            <div className="board-row">
              <Square value={squares[0]} onclick={()=>handleClick(0)}/>
              <Square value={squares[1]} onclick={()=>handleClick(1)}/>
              <Square value={squares[2]} onclick={()=>handleClick(2)}/>
            </div>
            <div className="board-row">
              <Square value={squares[3]}/>
              <Square value={squares[4]}/>
              <Square value={squares[5]}/>
            </div>
            <div className="board-row">
              <Square value={squares[6]}/>
              <Square value={squares[7]}/>
              <Square value={squares[8]}/>
            </div>
        </>
    )
}

const root = createRoot(document.getElementById('root'))
root.render(
  <StrictMode>
    <App/>
  </StrictMode>
)


</script>
---
你为什么要复制newSquares ，直接向我这样用squares 不行吗
```

### 1. React的不可变原则

React通过比较状态的引用来确定组件是否需要重新渲染，当你直接修改数组，（如squares）是，
你实际在修改其原始引用，这意味着即使你调用了`setSquares(squares)`, React也可能无法检测到
状态的变化，因为状态的引用并没有发生变化，

例如，在我的代码中
```javascript
squares[index] = squares[index] === 'X'?'Y':'Z';
setSquares(squares);
```
你直接修改了`squares`数组的内容，但数组的引用并没有发生变化，当你调用
setSquares(squares)时，React不会重新渲染组件，因为它认为状态并没有真正改变(引用没有改变)

### 2. 正确的更新状态

为了确保react能正确的检测到状态的变化，我们应该创建一个新的数组副本，并在副本上进行修改，
然后通过setSquares更新状态

```javascript
const newSquares = squares.slice(); // 创建square 的副本
newSquares[index] = squares[index] ==='X'?'Y':'Z';
setSquares(newSquares)
```

`slice()` 方法创建了`squares`数组的一个浅拷贝，因此`newSquares` 是一个新的数组引用。
当你通过`setSquares(newSquares)`更新状态时，React会检测到数组应用的变化，从而正确触发渲染