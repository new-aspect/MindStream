本教程中，您将构建一个小型井字棋游戏，本教程不假设任何现有React知识，
您将在本教程中学习的技术是构建任何React应用教程的基础，充分理解它将使得您对React有深入理解

### 开始检查代码

在CodeSandbox中，你将看到3个部分
```
├── package.json
├── public
│   └── index.html
└── src
    ├── App.js
    ├── index.js
    └── styles.css
```

选择App.js，您将看到
```javascript
export default function Square(){
    return <button className="square">X</button>
}
```

在浏览器能看到一个带有X的正方形

App.js创建了一个组件。在React中，组件是一段可以重用的代码，代表用户界面的一部分。组件用于呈现、管理和更新应用程序中的UI元素。

我们第一行定义了一个名为Square的函数，JavaScript的`export` 关键字使得该函数可以在次文件之外访问，`default` 关键字告诉你代码的其他文件它是您文件中的main函数

第二行返回一个按钮，JavaScrip的`return` 关键字意味着后面的任何内容都会作为值返回给函数的调用者，`<button>` 是一个JSX元素，JSX元素是JavaScript代码和HTML标记的组合，它用于描述您想要展示的内容。`className="square"` 是一个按钮元素属性或道具，告诉CSS应该如何设置按钮的样式。`X`是按钮内部显示的文本。


index.js
```js
import {StrictMode} from 'react';
import {createRoot} from 'react-dom/client'; //React 与Web 浏览器对话的库(React Dom)
import './styles.css' 

import App from './App' // 您在App.js中创建的组件
```

文件的其余部分将将所有组件组合在一起，并将最终产品注入public文件的index.html中

### 构建Board

让我们回到App.js。

目前棋盘只有一个方格，但你需要九个！但是如果直接复制粘贴，会报错
```javascript
export default function Square() {
    return <button className="square">X</button><button className="square">X</button>
}
```

```
/src/App.js: Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX Fragment <>...</>?
```

React要求返回单个元素，解决这个问题，你可以用判断`<>`和`</>`来包装多个相邻的JSX元素

```javascript
export default function Square(){
    return (
        <>
            <button className="square">X</button>
            <button className="square">X</button>
        </>
    )
}
```

复制九个我们发现变成一行了，这不是我们想要的棋盘网格

要解决这个问题，我们需要用<div>将方块分组并添加一些CSS类，当您执行时，您将为每个方块制定一个位置，以确保方块的位置

在App.js文件中，更新Square组件，如下

```javascript
export default function Square(){
    return (
        <>
            <div className="board-row">
                <button className="square">1</button>
                <button className="square">2</button>
                <button className="square">3</button>
            </div>
            <div className="board-row">
                <button className="square">4</button>
                <button className="square">5</button>
                <button className="square">6</button>
            </div>
            <div className="board-row">
                <button className="square">7</button>
                <button className="square">8</button>
                <button className="square">9</button>
            </div>
        </>
    )
}
```

在style.css里面定义CSS使用board-row的className对div进行样式设置，然后就是因为原来的不再是正方形了，我们改名为Board()

```javascript

function Square(){
    return <button className="square">1</button>
}

export default function Board(){
    return(
        <>
            <div className="board-row">
                <Square/>
                <Square/>
                <Square/>
            </div>
            <div className="board-row">
                <Square/>
                <Square/>
                <Square/>
            </div>
            <div className="board-row">
                <Square/>
                <Square/>
                <Square/>
            </div>
        </>
    )
}

```

这是我们看到都是111，我们希望传值成为123456789，用JSX的{value}传入值

```javascript
function Square({value}){
    return <button className="square">{value}</button>
}

export default function Board(){
    return(
        <>
            <div className="board-row">
                <Square value="1"/>
                <Square value="2"/>
                <Square value="3"/>
            </div>
            <div className="board-row">
                <Square value="4"/>
                <Square value="5"/>
                <Square value="6"/>
            </div>
            <div className="board-row">
                <Square value="7"/>
                <Square value="8"/>
                <Square value="9"/>
            </div>
        </>
    )
}
```

### 制作一个交互组件


```javascript
function Square({value}) {
    function handleClient() {
        console.log('clieck!');
    }

    return (
        <button
            className="square"
            onClieck={handleClieck} 
        >

        </button>
    )
}
```

React 有一个useStatue特殊函数，你可以从组件中调用这个函数，让他记住事物，

```javascript
import {useStatue} from 'react';

function Square() {
    const [value,setValue] = useStatue(null);

    function handleClick(){
        //...
    }
    //...
}
```

value存储值，setValue是一个可以更改函数的值，

现在，您更改当单击Square时显示X

```javascript
function Square(){
    const [value,setValue] = useStatue(null);

    function handleClick(){
        setValue('X');
    }

    return (
        <button 
            className="square"
            onClick={handleClick}
        >
            {value}
        </button>
    )
}
```

### 提升状态
目前，每个Square单独维护自己的状态，为了检查游戏中的获胜者，Board需要以某种方式了解9个Square组件中每个组件的状态

你可能会猜测Board询问每个Square的状态，尽管这种在React上面是可行的，但我们不鼓励，因为会让代码变得难以理解，容易出错并且难以重构。

相反，最好的方法是将游戏状态存在父Board中，而不是每个Square中，Board可以传递一个prop告诉每个Square要显示什么


要从多个子组件收集数据，或者让两个子组件之间相互通信，请在父组件中声明共享状态，父组件可以通过props将该状态传递会子组件中，使得
子组件之间和父组件保持同步

当React被重构时，将状态提升到父组件是很常见的

我们趁这个机会尝试一下
```js
export default function Board(){
    const [squares, setSquares] = useState(Array(9).fill(null))
    return (
        //...
    );
}

```

当你稍后填充棋盘是,会得到以下的squares数组
```
['O',null,'X','X','X','O','O',null]
```

```js
export default function Board() {
    const [squares,setSquares] = useState(Array(9).fill('X'));
    return (
        <>
            <div className="board-row">
                <Square value={squares[0]} />
                <Square value={squares[1]} />
                <Square value={squares[2]} />
            </div>
            <div className="board-row">
                <Square value={squares[3]} />
                <Square value={squares[4]} />
                <Square value={squares[5]} />
            </div>
            <div className="board-row">
                <Square value={squares[6]} />
                <Square value={squares[7]} />
                <Square value={squares[8]} />
            </div>
            
        </>
    )
}
```

接下来，您将尝试将i传递给handleClick，你尝试直接在JSX中将square的onSquareClick属性设置为handleClick(0) 如下所示，不起作用
```javascript
<Square value={squares[0] onSquareClick={handleClick(0)}}/>
```
会报错
```
Error: Too many re-renders. React limits the number of renders to prevent an infinite loop.
```
这是为什么不起作用的原因。handleClick(0)调用渲染组件的一部分，因为handleClick(0)通过调用setSquares该变了棋盘组件的状态，
所以整个棋盘组会将再次渲染。但这次运行handleClick(0), 导致无限循环

为什么没有早点发生？
当你传递`onSquareClick={handleClick}` 时，您将`handleClick` 函数作为prop向下传递，您没有叫他，

### 轮流
通过加一个新的状态xIsNext我们可以知道每次下的是什么样

```javascript
const[squares,setSquares] = useState(Array(9).fill(null));
const[xIsNext,setXIsNext] = useState(true)


const handleClick = (index) => {
    const newSquares = squares.slice();
    if (xIsNext) {
    newSquares[index] = 'X'
    setXIsNext(false)
    } else {
    newSquares[index] = 'Z'
    setXIsNext(true)
    }
    
    setSquares(newSquares);
}
```

防止重复点击已填写的方块格子
```javascript
    const handleClick = (index) => {
      // 防止重复点击已填写的方块格子
      if (squares[index] != null) {
        return
      }

      const newSquares = squares.slice();
      if (xIsNext) {
        newSquares[index] = 'X'
        setXIsNext(false)
      } else {
        newSquares[index] = 'Z'
        setXIsNext(true)
      }
      
      setSquares(newSquares);
    }
```

重构一下setXIsNext的逻辑
```javascript
const handleClick = (index) => {
    // 防止重复点击已填写的方块格子
    if (squares[index] != null) {
        return
    }

    const newSquares = squares.slice();
    if (xIsNext) {
        newSquares[index] = 'X'
    } else {
        newSquares[index] = 'O'
    }
    
    setSquares(newSquares);
    setXIsNext(!xIsNext)
}
```

### 检查获胜的逻辑
```javascript
function Square({value,onclick}){
    return <button className="square" onClick={onclick}>{value}</button>
}

function calculateWinner(squares) {
      const lines = [
        [0,1,2],
        [3,4,5],
        [6,7,8],
        [0,3,6],
        [1,4,7],
        [2,5,8],
        [0,4,8],
        [2,4,6]
      ];

      for(let i= 0; i<lines.length;i++){
        const [a,b,c] = lines[i]
        if (squares[a] && squares[a]===squares[b] && squares[a]===squares[c]){
          return squares[a];
        }
      }
      return null;
    }

let App = function Board(){
    const[squares,setSquares] = useState(Array(9).fill(null));
    const[xIsNext,setXIsNext] = useState(true)

    const handleClick = (index) => {
      // 防止重复点击已填写的方块格子，当有人获胜也无法点击格子
      if (squares[index] != null || calculateWinner(squares)) {
        return
      }

      const newSquares = squares.slice();
      if (xIsNext) {
        newSquares[index] = 'X'
      } else {
        newSquares[index] = 'O'
      }
      
      setSquares(newSquares);
      setXIsNext(!xIsNext)
    }

    return(
        <>
            <div className="board-row">
              <Square value={squares[0]} onclick={()=>handleClick(0)}/>
              <Square value={squares[1]} onclick={()=>handleClick(1)}/>
              <Square value={squares[2]} onclick={()=>handleClick(2)}/>
            </div>
            <div className="board-row">
              <Square value={squares[3]} onclick={()=>{handleClick(3)}}/>
              <Square value={squares[4]} onclick={()=>{handleClick(4)}}/>
              <Square value={squares[5]} onclick={()=>{handleClick(5)}}/>
            </div>
            <div className="board-row">
              <Square value={squares[6]} onclick={()=>{handleClick(6)}}/>
              <Square value={squares[7]} onclick={()=>{handleClick(7)}}/>
              <Square value={squares[8]} onclick={()=>{handleClick(8)}}/>
            </div>
        </>
    )
}
```

添加状态，知道是谁获胜了
```javascript
function Square({value,onclick}){
    return <button className="square" onClick={onclick}>{value}</button>
}

function calculateWinner(squares) {
      const lines = [
        [0,1,2],
        [3,4,5],
        [6,7,8],
        [0,3,6],
        [1,4,7],
        [2,5,8],
        [0,4,8],
        [2,4,6]
      ];

      for(let i= 0; i<lines.length;i++){
        const [a,b,c] = lines[i]
        if (squares[a] && squares[a]===squares[b] && squares[a]===squares[c]){
          return squares[a];
        }
      }
      return null;
    }

let App = function Board(){
    const[squares,setSquares] = useState(Array(9).fill(null));
    const[xIsNext,setXIsNext] = useState(true)

    const handleClick = (index) => {
      // 防止重复点击已填写的方块格子，当有人获胜也无法点击格子
      if (squares[index] != null || calculateWinner(squares)) {
        return
      }

      const newSquares = squares.slice();
      if (xIsNext) {
        newSquares[index] = 'X'
      } else {
        newSquares[index] = 'O'
      }
      
      setSquares(newSquares);
      setXIsNext(!xIsNext)
    }

    const winner = calculateWinner(squares);
    let status;
    if (winner) {
      status = "获胜者："+winner;
    } else {
      status = "下一位玩家是："+(xIsNext ? "X":"O")
    }

    return(
        <>
            <div className="status">{status}</div>
            <div className="board-row">
              <Square value={squares[0]} onclick={()=>handleClick(0)}/>
              <Square value={squares[1]} onclick={()=>handleClick(1)}/>
              <Square value={squares[2]} onclick={()=>handleClick(2)}/>
            </div>
            <div className="board-row">
              <Square value={squares[3]} onclick={()=>{handleClick(3)}}/>
              <Square value={squares[4]} onclick={()=>{handleClick(4)}}/>
              <Square value={squares[5]} onclick={()=>{handleClick(5)}}/>
            </div>
            <div className="board-row">
              <Square value={squares[6]} onclick={()=>{handleClick(6)}}/>
              <Square value={squares[7]} onclick={()=>{handleClick(7)}}/>
              <Square value={squares[8]} onclick={()=>{handleClick(8)}}/>
            </div>
        </>
    )
}
```

### 添加时间旅行，就是点击按钮可以回滚到之前的步骤